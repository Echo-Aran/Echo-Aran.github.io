<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/"/>
    <url>/2024/02/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Too-many-connections解决方案"><a href="#Too-many-connections解决方案" class="headerlink" title="Too many connections解决方案"></a>Too many connections解决方案</h2><p>too many connections会造成新的链接处于阻塞状态，只有等原有链接到达</p><blockquote><p>Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: </p><p>Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: </p><p>HikariPool-1 - Connection is not available, request timed out after 30059ms.] with root cause</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>　　 my.ini 中设定的并发连接数太少或者系统繁忙导致连接数被占满。</p><p>　　<strong>连接数超过了 MySQL 设置的值，与 max_connections 和 wait_timeout 都有关。</strong></p><p>　　<strong>wait_timeout 的值越大，连接的空闲等待就越长，这样就会造成当前连接数越大。</strong></p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>打开 MYSQL 安装目录打开 my.ini 找到 max_connections 默认是 100， 一般设置到500～1000比较合适，重启 MySQL </p><p><strong>显示哪些线程正在运行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> processlist;<br></code></pre></td></tr></table></figure><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><img src="/../image/8f851d2de74b42beaf999998c12f1639.png" alt="img"></p><p>１.　SLEEP<br>线程正在等待客户端发送新的请求。<br>２.　QUERY<br>线程正在执行查询或者正在将结果发送给客户端。　<br>３.　LOCKED<br>在MYSQL服务层，该线程正在等待表锁。在存储引擎级别实现的锁，如INNODB的行锁，并不会体现在线程状态中。　对于MYISAM来说这是一个比较典型的状态。但在其他没有行锁的引擎中也经常会出现。　<br>４.　ANALYZING　AND STATISTICS<br>线程正在收集存储引擎的统计信息，　并生成查询的执行计划。<br>５.　COPYING TO TMP TABLE （ON DISK）<br>线程正在执行查询，　并且将其结果集都复制到一个临时文件中，　这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，　或者是UNION操作。　如果这个状态后面还有ON DISK的标　，　那表示MYSQL正在将一个内存临时表放到磁盘上。</p><p>６.　SORTING RESULT<br>线程正在对结果集进行排序。</p><p>７.　SENDING DATA<br>线程可能在多个状态之间传送数据，或者生成结果集，或者在向客户端返回数据。</p><p><strong>sleep休眠状态的连接过多，则应该从两方面注意:</strong></p><ul><li><p>wait_timeout：mysql在关闭一个非交互的连接(<strong>通过jdbc连接数据库</strong>是非交互式连接 )之前要等待的秒数 , 默认是28800s , 设置过大有弊端，其体现就是MySQL里大量的SLEEP进程无法及时释放，拖累系统性能。如果设置过小，可能会遭遇到“MySQL has gone away”之类的问题</p></li><li><p>interactive_timeout：交互超时时间（通过<strong>mysql客户端连接数据库</strong>是交互式连接）</p></li></ul><p><strong>max_connections最大连接数也需要注意：</strong></p><p>对于mysql服务器最大连接数值的设置范围比较理想的是：服务器使用的最大连接数值占服务器上限连接数值的比例值在10%以上，如果在10%以下，说明mysql服务器最大连接上限值设置过高。</p><p>　　</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>连接数设置多少是合理的?</strong></p><p>查看mysql的最大连接数：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">　show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%max_connections%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查看服务器响应的最大连接数:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Max_used_connections&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/../image/798214-20160727105003091-189174906.png" alt="img"></p><p>服务器响应的最大连接数为3，远低于mysql服务器允许的最大连接数值</p><p>对于mysql服务器最大连接数值的设置范围比较理想的是：服务器响应的最大连接数值占服务器上限连接数值的比例值在10%以上，如果在10%以下，说明mysql服务器最大连接上限值设置过高。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Max_used_connections</span> / max_connections * <span class="hljs-number">100</span>% = <span class="hljs-number">3</span>/<span class="hljs-number">512</span> *<span class="hljs-number">100</span>% ≈ <span class="hljs-number">0</span>.<span class="hljs-number">6</span>%<br></code></pre></td></tr></table></figure><p><strong>wait_timeout</strong></p><p>wait_timeout — 指的是mysql在关闭一个非交互的连接之前所要等待的秒数</p><p>如果你没有修改过MySQL的配置，wait_timeout的初始值是28800</p><p>wait_timeout 过大有弊端，其体现就是MySQL里大量的SLEEP进程无法及时释放，拖累系统性能，不过也不能把这个指设置的过小，否则你可能会遭遇到“MySQL has gone away”之类的问题</p><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;wait_timeout&#x27;</span>;  <br></code></pre></td></tr></table></figure><p>设置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> global <span class="hljs-attribute">wait_timeout</span>=100;  <br></code></pre></td></tr></table></figure><p><strong>interactive_time</strong></p><p>— 指的是mysql在关闭一个交互的连接之前所要等待的秒数 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> global  <span class="hljs-attribute">interactive_timeout</span>=300;<br></code></pre></td></tr></table></figure><p>mysql终端查看timeout的设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%timeout%&#x27;</span>; <br></code></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/798214/201608/798214-20160809104957684-2053356148.png" alt="img"></p><p><strong>总结</strong></p><p>MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此客户端在连接到MySQL Server处理完相应的操作后，应该断开连接并释放占用的内存。</p><p>如果MySQL Server有大量的闲置连接，不仅会白白消耗内存，而且如果连接一直在累加而不断开，最终肯定会达到MySQL Server的连接上限数，这会报’too many connections’的错误。</p><p>对于wait_timeout的值设定，应该根据系统的运行情况来判断。在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，可以进行适当的调整小些。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计技巧</title>
    <link href="/2024/02/20/%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/02/20/%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>ID最好作为字符串返回。</p><img src="assets/image-20240222015035451.png" alt="image-20240222015035451" style="zoom:50%;" /> <h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">markOrderPaySuccess</span><span class="hljs-params">(Long orderId)</span> &#123;<br>        <span class="hljs-comment">// 1.查询订单</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> getById(orderId);<br>        <span class="hljs-comment">// 2.判断订单状态</span><br>        <span class="hljs-keyword">if</span> (old == <span class="hljs-literal">null</span> || old.getStatus() != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 订单不存在或者订单状态不是1，放弃处理</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3.尝试更新订单</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        order.setId(orderId);<br>        order.setStatus(<span class="hljs-number">2</span>);<br>        order.setPayTime(LocalDateTime.now());<br>        updateById(order);<br>    &#125;<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">markOrderPaySuccess</span><span class="hljs-params">(Long orderId)</span> &#123;<br>    <span class="hljs-comment">// UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</span><br>    lambdaUpdate()<br>            .set(Order::getStatus, <span class="hljs-number">2</span>)<br>            .set(Order::getPayTime, LocalDateTime.now())<br>            .eq(Order::getId, orderId)<br>            .eq(Order::getStatus, <span class="hljs-number">1</span>)<br>            .update();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud</title>
    <link href="/2024/02/19/SpringCloud/"/>
    <url>/2024/02/19/SpringCloud/</url>
    
    <content type="html"><![CDATA[<p>配置类：封装一系列属性</p><p>@ConfigurationProperties：配置信息来源</p><p>@<font color=red>Enable</font>ConfigurationProperties（配置类）：激活配置类</p><p>配置类：</p><p>登记一些类：比如拦截器等</p><p>配置类如果要生效，必须要被spring扫到才可以</p><blockquote><p>知识点：springboot 自动装配原理</p></blockquote><p>网关：底层不是springmvc，底层是webflux，是一种非响应式编程</p><p>WebMvcConfigurer 是针对SpringMVC的</p><p>条件注解：</p><p>@ConditionalOnClass : 制定条件，符合条件的才执行</p><p>Spring MVC最核心的类 DispatcherServlet</p><p>微服务基于springmvc的思想，aop等仍然可以用于微服务。</p><p>网关的请求是网关底层自己去发的</p><p>什么是ApplicationContext</p><img src="../image/image-20240219170404316.png" alt="image-20240219170404316" style="zoom: 33%;" /> ]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>买阿里云服务器踩的坑以及端口号放行</title>
    <link href="/2024/02/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7/"/>
    <url>/2024/02/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="阿里云服务器没有公网ip"><a href="#阿里云服务器没有公网ip" class="headerlink" title="阿里云服务器没有公网ip"></a>阿里云服务器没有公网ip</h2><p>服务器有两个ip，公网和内网</p><p>如果在购买的时候没有选择带宽（即带宽为0），那么是不会给分配公网ip</p><blockquote><p>算是阿里云的消费陷阱，因为公网ip要花钱卖</p></blockquote><p><strong>解决有两种办法</strong></p><ol><li>钞能力</li><li>更改套餐配置，将带宽改为4M</li></ol><h2 id="安全组设置"><a href="#安全组设置" class="headerlink" title="安全组设置"></a>安全组设置</h2><p>阿里云和腾讯云差不多，进行端口号的放行时，首先要在安全组里设置，并且要手动在云服务的防火墙开启端口号才算成立</p><blockquote><p>仅仅在安全组里设置端口号里设置是不行的！！！！</p></blockquote><p>防火墙相关操作如下</p><h4 id="1、查看防火墙状态"><a href="#1、查看防火墙状态" class="headerlink" title="1、查看防火墙状态"></a>1、查看防火墙状态</h4><p>​firewall-cmd –state</p><h4 id="2、开启防火墙"><a href="#2、开启防火墙" class="headerlink" title="2、开启防火墙"></a>2、开启防火墙</h4><p>​systemctl start firewalld.service</p><h4 id="3、开启端口（以端口443为例）"><a href="#3、开启端口（以端口443为例）" class="headerlink" title="3、开启端口（以端口443为例）"></a>3、开启端口（以端口443为例）</h4><p>​firewall-cmd –zone&#x3D;public –add-port&#x3D;443&#x2F;tcp –permanent命令</p><blockquote><p>–zone&#x3D;public表示作用域为公共的<br>–add-port&#x3D;443&#x2F;tcp添加tcp协议的端口端口号为443<br>–permanent永久生效，如果没有此参数，则只能维持当前 服 务生命周期内，重新启动后失效；</p></blockquote><h4 id="4、重启防火墙"><a href="#4、重启防火墙" class="headerlink" title="4、重启防火墙"></a>4、重启防火墙</h4><p>​systemctl restart firewalld.service</p><h4 id="5、重新载入防火墙"><a href="#5、重新载入防火墙" class="headerlink" title="5、重新载入防火墙"></a>5、重新载入防火墙</h4><p>​firewall-cmd –reload</p><h4 id="6、查看已开启的端口"><a href="#6、查看已开启的端口" class="headerlink" title="6、查看已开启的端口"></a>6、查看已开启的端口</h4><p>​firewall-cmd –list-ports</p><h4 id="7、关闭端口"><a href="#7、关闭端口" class="headerlink" title="7、关闭端口"></a>7、关闭端口</h4><p>​firewall-cmd –zone&#x3D;public –remove-port&#x3D;8080&#x2F;tcp –permanent</p><pre><code class="hljs"> 重复第4、5步操作，即可成功关闭</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring常用注解</title>
    <link href="/2024/01/22/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <url>/2024/01/22/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring部分"><a href="#Spring部分" class="headerlink" title="Spring部分"></a><strong>Spring部分</strong></h2><h4 id="1-声明bean的注解"><a href="#1-声明bean的注解" class="headerlink" title="1.声明bean的注解"></a>1.声明bean的注解</h4><p><strong>@Component</strong> 组件，没有明确的角色</p><p><strong>@Service</strong> 在业务逻辑层使用（service层）</p><p><strong>@Repository</strong>在数据访问层使用（dao层）</p><p><strong>@Controller</strong> 在展现层使用，控制器的声明（C）</p><h4 id="2-注入bean的注解"><a href="#2-注入bean的注解" class="headerlink" title="2.注入bean的注解"></a>2.注入bean的注解</h4><p>@Autowired：由Spring提供</p><p>@Inject：由JSR-330提供</p><p>@Resource：由JSR-250提供</p><p>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p><h4 id="3-java配置类相关注解"><a href="#3-java配置类相关注解" class="headerlink" title="3.java配置类相关注解"></a>3.java配置类相关注解</h4><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</p><p>@Configuration 声明当前类为配置类，其中内部组合了@<a href="https://so.csdn.net/so/search?q=Component&spm=1001.2101.3001.7020">Component</a>注解，表明这个类是一个bean（类上）</p><p>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）</p><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p><h4 id="4-切面（AOP）相关注解"><a href="#4-切面（AOP）相关注解" class="headerlink" title="4.切面（AOP）相关注解"></a>4.切面（AOP）相关注解</h4><p>Spring支持AspectJ的注解式切面编程。</p><p><strong>@Aspect</strong> 声明一个切面（类上）<br>使用**@After、@Before、@Around**定义建言（advice），可直接将拦截规则（切点）作为参数。</p><p><strong>@After</strong> 在方法执行之后执行（方法上）<br><strong>@Before</strong>在方法执行之前执行（方法上）<br><strong>@Around</strong> 在方法执行之前与之后执行（方法上）</p><p><strong>@PointCut</strong> 声明切点<br>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p><h4 id="5-Bean的属性支持"><a href="#5-Bean的属性支持" class="headerlink" title="5.@Bean的属性支持"></a>5.@Bean的属性支持</h4><p><em><strong>*@Scope*</strong></em> 设置Spring容器如何新建Bean实例（方法上，得有@Bean）<br>其设置类型包括：</p><p>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）,<br>Protetype （每次调用新建一个bean）,<br>Request （web项目中，给每个http request新建一个bean）,<br>Session （web项目中，给每个http session新建一个bean）,<br>GlobalSession（给每一个 global http session新建一个Bean实例）</p><p><strong>@StepScope</strong> 在Spring Batch中还有涉及</p><p><strong>@PostConstruct</strong>由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</p><p><strong>@PreDestory</strong> 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p><h4 id="6-Value注解"><a href="#6-Value注解" class="headerlink" title="6.@Value注解"></a>6.@Value注解</h4><p><strong>@Value</strong> 为属性注入值（属性上）<br>支持如下方式的注入：<br>》注入普通字符</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;Michael Jackson&quot;</span>)<br><span class="hljs-title class_">String</span> name;<br></code></pre></td></tr></table></figure><p>》注入操作系统属性</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">#&#123;systemProperties[<span class="hljs-string">&#x27;os.name&#x27;</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">String</span> osName;<br></code></pre></td></tr></table></figure><p>》注入表达式结果</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">#&#123; T(java.lang.<span class="hljs-built_in">Math</span>).random() * <span class="hljs-number">100</span> &#125;</span>&quot;</span>)<br><span class="hljs-built_in">String</span> randomNumber;<br></code></pre></td></tr></table></figure><p>》注入其它bean属性</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">#&#123;domeClass.name&#125;</span>&quot;</span>)<br><span class="hljs-built_in">String</span> name;<br></code></pre></td></tr></table></figure><p>》注入文件资源</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;classpath:com/hgs/hello/test.txt&quot;</span>)<br><span class="hljs-title class_">String</span> <span class="hljs-title class_">Resource</span> file;<br></code></pre></td></tr></table></figure><p>》注入网站资源</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Value(<span class="hljs-string">&quot;http://www.cznovel.com&quot;</span>)</span><br>Resource url;<br></code></pre></td></tr></table></figure><p>》<strong>注入配置文件</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;book.name&#125;</span>&quot;</span>)</span><br>String bookName;<br></code></pre></td></tr></table></figure><p>注入配置使用方法：<br>① 编写配置文件（test.properties）</p><p>book.name&#x3D;《三体》</p><p>② @PropertySource 加载配置文件(类上)</p><p>@PropertySource(“classpath:com&#x2F;hgs&#x2F;hello&#x2F;test&#x2F;test.propertie”)</p><p>③ 还需配置一个PropertySourcesPlaceholderConfigurer的bean。</p><h4 id="7-环境切换"><a href="#7-环境切换" class="headerlink" title="7.环境切换"></a>7.环境切换</h4><p>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</p><p><em><strong>*@Conditional*</strong></em> Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p><h4 id="8-异步相关"><a href="#8-异步相关" class="headerlink" title="8.异步相关"></a>8.异步相关</h4><p><strong>@EnableAsync</strong> 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）</p><p><strong>@Async</strong> 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上<em>所有的方法都将异步</em>，需要@EnableAsync开启异步任务）</p><h4 id="9-定时任务相关"><a href="#9-定时任务相关" class="headerlink" title="9.定时任务相关"></a>9.定时任务相关</h4><p><strong>@EnableScheduling</strong> 在配置类上使用，开启计划任务的支持（类上）</p><p><strong>@Scheduled</strong> 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</p><h4 id="10-Enable注解说明"><a href="#10-Enable注解说明" class="headerlink" title="10.@Enable注解说明"></a>10.@Enable注解说明</h4><p>这些注解主要用来开启对xxx的支持。<br><strong>@EnableAspectJAutoProxy</strong> 开启对AspectJ自动代理的支持</p><p><strong>@EnableAsync</strong> 开启异步方法的支持</p><p><strong>@EnableScheduling</strong> 开启计划任务的支持</p><p><strong>@EnableWebMvc</strong> 开启Web MVC的配置支持</p><p><strong>@EnableConfigurationProperties</strong> 开启对@ConfigurationProperties注解配置Bean的支持</p><p><strong>@EnableJpaRepositories</strong> 开启对SpringData JPA Repository的支持</p><p><strong>@EnableTransactionManagement</strong> 开启注解式事务的支持</p><p><strong>@EnableTransactionManagement</strong> 开启注解式事务的支持</p><p><strong>@EnableCaching</strong> 开启注解式的缓存支持</p><p>11.测试相关注解</p><p><strong>@RunWith</strong> 运行器，Spring中通常用于对JUnit的支持</p><p><strong>@ContextConfiguration</strong> 用来加载配置ApplicationContext，其中classes属性用来加载配置类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes=&#123;TestConfig.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KjtTest</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;KjtTest&quot;</span>);<br> <br>    <span class="hljs-meta">@Autowired</span><br>    Service service;<br> <br> <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SpringMVC部分"><a href="#SpringMVC部分" class="headerlink" title="SpringMVC部分"></a>SpringMVC部分</h3><p><strong>@EnableWebMvc</strong> 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p><p><strong>@Controller</strong>声明该类为SpringMVC中的Controller</p><p><strong>@RequestMapping</strong> 用于映射Web请求，包括访问路径和参数（类或方法上）</p><p><strong>@ResponseBody</strong> 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p><p><strong>@RequestBody</strong> 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p><p><strong>@PathVariable</strong> 用于接收路径参数，比如@RequestMapping(“&#x2F;hello&#x2F;{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p><strong>@RestController</strong> 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p><p><strong>@ControllerAdvice</strong> 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，<br>这对所有注解了 @RequestMapping的控制器内的方法有效。</p><p><strong>@ExceptionHandler</strong> 用于全局处理控制器里的异常</p><p><strong>@InitBinder</strong> 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p><p><strong>@ModelAttribute</strong> 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。</p><p>如有遗漏或有误的地方，希望帮忙指出。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Quick Start</title>
    <link href="/2024/01/22/hello-world/"/>
    <url>/2024/01/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
